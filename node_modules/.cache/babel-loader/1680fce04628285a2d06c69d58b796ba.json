{"ast":null,"code":"export function getMergeSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  const auxiliaryArray = array.slice();\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n  return animations;\n}\n\nfunction mergeSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n  if (startIdx === endIdx) return;\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations) {\n  let k = startIdx;\n  let i = startIdx;\n  let j = middleIdx + 1;\n\n  while (i <= middleIdx && j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, j]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([i, j]);\n\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n      // We overwrite the value at index k in the original array with the\n      // value at index i in the auxiliary array.\n      animations.push([k, auxiliaryArray[i]]);\n      mainArray[k++] = auxiliaryArray[i++];\n    } else {\n      // We overwrite the value at index k in the original array with the\n      // value at index j in the auxiliary array.\n      animations.push([k, auxiliaryArray[j]]);\n      mainArray[k++] = auxiliaryArray[j++];\n    }\n  }\n\n  while (i <= middleIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([i, i]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([i, i]); // We overwrite the value at index k in the original array with the\n    // value at index i in the auxiliary array.\n\n    animations.push([k, auxiliaryArray[i]]);\n    mainArray[k++] = auxiliaryArray[i++];\n  }\n\n  while (j <= endIdx) {\n    // These are the values that we're comparing; we push them once\n    // to change their color.\n    animations.push([j, j]); // These are the values that we're comparing; we push them a second\n    // time to revert their color.\n\n    animations.push([j, j]); // We overwrite the value at index k in the original array with the\n    // value at index j in the auxiliary array.\n\n    animations.push([k, auxiliaryArray[j]]);\n    mainArray[k++] = auxiliaryArray[j++];\n  }\n} // https://github.com/Kevin6525/Sorting-Visualizer/blob/master/src/sortingAlgorithms/sortingAlgorithms.js\n\n\nfunction swap(arr, val1, val2) {\n  let temp = arr[val2];\n  arr[val2] = arr[val1];\n  arr[val1] = temp;\n}\n\nexport function getBubbleSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  let size = array.length;\n  doBubbleSort(array, size, animations);\n  return animations;\n}\n\nfunction doBubbleSort(mainArray, size, animations) {\n  for (let i = 0; i < size - 1; i++) {\n    // Last i elements are already in place\n    for (let j = 0; j < size - i - 1; j++) {\n      animations.push([i, j, false]);\n      animations.push([i, j, false]); // Checking if the item at present iteration\n      // is greater than the next iteration\n\n      if (mainArray[j] > mainArray[j + 1]) {\n        // If the condition is true then swap them\n        animations.push([j, mainArray[j + 1], true]);\n        animations.push([j + 1, mainArray[j], true]);\n        swap(mainArray, j, j + 1);\n      }\n    }\n  }\n}\n\nexport function getQuickSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  doQuickSort(array, 0, array.length - 1, animations);\n  return animations;\n}\n\nfunction doQuickSort(array, lowIndex, highIndex, animations) {\n  if (lowIndex >= highIndex) return;\n  let pivot = getPivot(array, lowIndex, highIndex, animations);\n  doQuickSort(array, lowIndex, pivot - 1, animations);\n  doQuickSort(array, pivot + 1, highIndex, animations);\n} //This is the function to find the partition the array through pivot points\n\n\nfunction getPivot(array, lowIndex, highIndex, animations) {\n  // Standard quicksort, we set our last element to be our pivot value\n  // Pivot index is where the pivot value belongs in the array once sorted\n  let pivotIdx = lowIndex;\n  let pivotVal = array[highIndex]; // Iterate through the list, note we use lowIndex as the starting index (For recursive calls)\n\n  for (let i = lowIndex; i < highIndex; i++) {\n    //Push the animation twice, Once to highlight it, second to reset color\n    animations.push([pivotIdx, i, false]);\n    animations.push([pivotIdx, i, false]); //If the current value is less than the pivot value, than we increment pivot index\n\n    if (array[i] < pivotVal) {\n      //Push two animations to swap bar heights (Use true to indicate a change)\n      animations.push([pivotIdx, array[i], true]);\n      animations.push([i, array[pivotIdx], true]);\n      swap(array, i, pivotIdx);\n      pivotIdx++;\n    }\n  } //Once we reach the end, we highlight the pivot values determined index and the original index\n  //Reset the colors and commit the swap in bar heights\n\n\n  animations.push([pivotIdx, highIndex, false]);\n  animations.push([pivotIdx, highIndex, false]);\n  animations.push([pivotIdx, array[highIndex], true]);\n  animations.push([highIndex, array[pivotIdx], true]);\n  swap(array, pivotIdx, highIndex);\n  return pivotIdx;\n}\n\nexport function getHeapSortAnimations(array) {\n  const animations = [];\n  if (array.length <= 1) return array;\n  let size = array.length;\n  doHeapSort(array, size, animations);\n  return animations;\n}\n\nfunction doHeapSort(array, size, animations) {\n  for (let i = size / 2 - 1; i >= 0; i--) {\n    heapify(array, size, i, animations);\n  }\n\n  for (let i = size - 1; i >= 0; i--) {\n    animations.push([i, array[0], true]);\n    animations.push([0, array[i], true]);\n    swap(array, i, 0);\n    heapify(array, i, 0, animations);\n  }\n}\n\nfunction heapify(array, size, i, animations) {\n  //n is the size of the heap\n  //rooted at index i\n  let root = i;\n  let left = 2 * i + 1;\n  let right = 2 * i + 2;\n\n  if (left < size && array[root] < array[left]) {\n    animations.push([root, left, false]);\n    animations.push([root, left, false]);\n    root = left;\n  }\n\n  if (right < size && array[root] < array[right]) {\n    animations.push([root, right, false]);\n    animations.push([root, right, false]);\n    root = right;\n  }\n\n  if (root != i) {\n    animations.push([root, array[i], true]);\n    animations.push([i, array[root], true]); //If root is not i, then swap the values, call heapify recursively\n\n    swap(array, root, i);\n    heapify(array, size, root, animations);\n  }\n}","map":{"version":3,"sources":["/Users/kimberlyashman/Workspace/web-fun/sorting-visualizer/src/sortingAlgorithms/sortingAlgorithms.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","doMerge","k","i","j","push","swap","arr","val1","val2","temp","getBubbleSortAnimations","size","doBubbleSort","getQuickSortAnimations","doQuickSort","lowIndex","highIndex","pivot","getPivot","pivotIdx","pivotVal","getHeapSortAnimations","doHeapSort","heapify","root","left","right"],"mappings":"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","sourcesContent":["export function getMergeSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    const auxiliaryArray = array.slice();\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n    return animations;\n}\n\nfunction mergeSortHelper(\n    mainArray,\n    startIdx,\n    endIdx,\n    auxiliaryArray,\n    animations,\n) {\n    if (startIdx === endIdx) return;\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(\n    mainArray,\n    startIdx,\n    middleIdx,\n    endIdx,\n    auxiliaryArray,\n    animations,\n) {\n    let k = startIdx;\n    let i = startIdx;\n    let j = middleIdx + 1;\n    while (i <= middleIdx && j <= endIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, j]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, j]);\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n            // We overwrite the value at index k in the original array with the\n            // value at index i in the auxiliary array.\n            animations.push([k, auxiliaryArray[i]]);\n            mainArray[k++] = auxiliaryArray[i++];\n        } else {\n            // We overwrite the value at index k in the original array with the\n            // value at index j in the auxiliary array.\n            animations.push([k, auxiliaryArray[j]]);\n            mainArray[k++] = auxiliaryArray[j++];\n        }\n    }\n    while (i <= middleIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, i]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, i]);\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, auxiliaryArray[i]]);\n        mainArray[k++] = auxiliaryArray[i++];\n    }\n    while (j <= endIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([j, j]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([j, j]);\n        // We overwrite the value at index k in the original array with the\n        // value at index j in the auxiliary array.\n        animations.push([k, auxiliaryArray[j]]);\n        mainArray[k++] = auxiliaryArray[j++];\n    }\n}\n// https://github.com/Kevin6525/Sorting-Visualizer/blob/master/src/sortingAlgorithms/sortingAlgorithms.js\nfunction swap(arr, val1, val2)\n{\n    let temp = arr[val2];\n    arr[val2] = arr[val1];\n    arr[val1] = temp;\n}\n\nexport function getBubbleSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    let size = array.length;\n    doBubbleSort(array, size, animations);\n    return animations;\n}\n\nfunction doBubbleSort(mainArray, size, animations) {\n    for (let i = 0; i <size -1; i++) {\n\n        // Last i elements are already in place\n        for (let j = 0; j < (size - i - 1); j++) {\n            animations.push([i, j, false]);\n            animations.push([i, j, false]);\n            // Checking if the item at present iteration\n            // is greater than the next iteration\n            if (mainArray[j] > mainArray[j + 1]) {\n\n                // If the condition is true then swap them\n                animations.push([j,mainArray[j+1],true]);\n                animations.push([j+1,mainArray[j],true]);\n                swap(mainArray,j,j+1);\n            }\n        }\n    }\n}\n\n\nexport function getQuickSortAnimations(array) {\n    const animations = [];\n    if(array.length <= 1) return array;\n    doQuickSort(array, 0, array.length - 1, animations);\n    return animations;\n}\nfunction doQuickSort(array, lowIndex, highIndex, animations)\n{\n    if(lowIndex >= highIndex) return;\n    let pivot = getPivot(array, lowIndex, highIndex, animations);\n    doQuickSort(array, lowIndex, pivot - 1, animations);\n    doQuickSort(array, pivot + 1, highIndex, animations);\n}\n\n//This is the function to find the partition the array through pivot points\nfunction getPivot(array, lowIndex, highIndex, animations)\n{\n    // Standard quicksort, we set our last element to be our pivot value\n    // Pivot index is where the pivot value belongs in the array once sorted\n    let pivotIdx = lowIndex\n    let pivotVal = array[highIndex];\n    // Iterate through the list, note we use lowIndex as the starting index (For recursive calls)\n    for(let i = lowIndex; i < highIndex; i ++)\n    {\n        //Push the animation twice, Once to highlight it, second to reset color\n        animations.push([pivotIdx, i, false]);\n        animations.push([pivotIdx, i, false]);\n        //If the current value is less than the pivot value, than we increment pivot index\n        if(array[i] < pivotVal)\n        {\n            //Push two animations to swap bar heights (Use true to indicate a change)\n            animations.push([pivotIdx, array[i], true]);\n            animations.push([i, array[pivotIdx], true]);\n            swap(array,i,pivotIdx);\n            pivotIdx ++;\n        }\n    }\n    //Once we reach the end, we highlight the pivot values determined index and the original index\n    //Reset the colors and commit the swap in bar heights\n    animations.push([pivotIdx, highIndex, false]);\n    animations.push([pivotIdx, highIndex, false]);\n    animations.push([pivotIdx, array[highIndex], true]);\n    animations.push([highIndex, array[pivotIdx], true]);\n    swap(array, pivotIdx, highIndex);\n    return pivotIdx;\n}\n\nexport function getHeapSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    let size = array.length;\n    doHeapSort(array, size, animations);\n    return animations;\n}\n\nfunction doHeapSort(array, size, animations)\n{\n    for (let i = (size/2 -1); i >= 0; i--){\n        heapify(array,size,i,animations);\n    }\n\n    for (let i = size-1; i >=0; i--){\n        animations.push([i, array[0], true]);\n        animations.push([0, array[i], true]);\n        swap(array, i, 0);\n        heapify(array, i, 0, animations);\n    }\n\n\n}\n\nfunction heapify(array, size, i, animations) {\n    //n is the size of the heap\n    //rooted at index i\n\n    let root = i;\n    let left = 2*i + 1;\n    let right = 2*i + 2;\n\n    if ((left < size) && (array[root] < array[left])){\n        animations.push([root, left, false]);\n        animations.push([root, left, false]);\n        root = left;\n    }\n\n    if ((right < size) && (array[root] < array[right])){\n        animations.push([root, right, false]);\n        animations.push([root, right, false]);\n        root = right;\n    }\n\n    if (root != i){\n        animations.push([root, array[i], true]);\n        animations.push([i, array[root], true]);\n        //If root is not i, then swap the values, call heapify recursively\n        swap(array, root, i);\n        heapify(array, size, root, animations);\n    }\n\n}"]},"metadata":{},"sourceType":"module"}