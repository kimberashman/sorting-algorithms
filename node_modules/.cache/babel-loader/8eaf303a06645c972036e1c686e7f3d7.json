{"ast":null,"code":"export function getMergeSortAnimations(array){var animations=[];if(array.length<=1)return array;var auxiliaryArray=array.slice();mergeSortHelper(array,0,array.length-1,auxiliaryArray,animations);return animations;}function mergeSortHelper(mainArray,startIdx,endIdx,auxiliaryArray,animations){if(startIdx===endIdx)return;var middleIdx=Math.floor((startIdx+endIdx)/2);mergeSortHelper(auxiliaryArray,startIdx,middleIdx,mainArray,animations);mergeSortHelper(auxiliaryArray,middleIdx+1,endIdx,mainArray,animations);doMerge(mainArray,startIdx,middleIdx,endIdx,auxiliaryArray,animations);}function doMerge(mainArray,startIdx,middleIdx,endIdx,auxiliaryArray,animations){var k=startIdx;var i=startIdx;var j=middleIdx+1;while(i<=middleIdx&&j<=endIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,j]);if(auxiliaryArray[i]<=auxiliaryArray[j]){// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,auxiliaryArray[i]]);mainArray[k++]=auxiliaryArray[i++];}else{// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,auxiliaryArray[j]]);mainArray[k++]=auxiliaryArray[j++];}}while(i<=middleIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([i,i]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([i,i]);// We overwrite the value at index k in the original array with the\n// value at index i in the auxiliary array.\nanimations.push([k,auxiliaryArray[i]]);mainArray[k++]=auxiliaryArray[i++];}while(j<=endIdx){// These are the values that we're comparing; we push them once\n// to change their color.\nanimations.push([j,j]);// These are the values that we're comparing; we push them a second\n// time to revert their color.\nanimations.push([j,j]);// We overwrite the value at index k in the original array with the\n// value at index j in the auxiliary array.\nanimations.push([k,auxiliaryArray[j]]);mainArray[k++]=auxiliaryArray[j++];}}// https://github.com/Kevin6525/Sorting-Visualizer/blob/master/src/sortingAlgorithms/sortingAlgorithms.js\nfunction swap(arr,val1,val2){var temp=arr[val2];arr[val2]=arr[val1];arr[val1]=temp;}export function getBubbleSortAnimations(array){var animations=[];if(array.length<=1)return array;var size=array.length;doBubbleSort(array,size,animations);return animations;}function doBubbleSort(mainArray,size,animations){for(var i=0;i<size-1;i++){// Last i elements are already in place\nfor(var j=0;j<size-i-1;j++){animations.push([i,j,false]);animations.push([i,j,false]);// Checking if the item at present iteration\n// is greater than the next iteration\nif(mainArray[j]>mainArray[j+1]){// If the condition is true then swap them\nanimations.push([j,mainArray[j+1],true]);animations.push([j+1,mainArray[j],true]);swap(mainArray,j,j+1);}}}}export function getQuickSortAnimations(array){var animations=[];if(array.length<=1)return array;doQuickSort(array,0,array.length-1,animations);return animations;}function doQuickSort(array,lowIndex,highIndex,animations){if(lowIndex>=highIndex)return;var pivot=getPivot(array,lowIndex,highIndex,animations);doQuickSort(array,lowIndex,pivot-1,animations);doQuickSort(array,pivot+1,highIndex,animations);}//This is the function to find the partition the array through pivot points\nfunction getPivot(array,lowIndex,highIndex,animations){// Standard quicksort, we set our last element to be our pivot value\n// Pivot index is where the pivot value belongs in the array once sorted\nvar pivotIdx=lowIndex;var pivotVal=array[highIndex];// Iterate through the list, note we use lowIndex as the starting index (For recursive calls)\nfor(var i=lowIndex;i<highIndex;i++){//Push the animation twice, Once to highlight it, second to reset color\nanimations.push([pivotIdx,i,false]);animations.push([pivotIdx,i,false]);//If the current value is less than the pivot value, than we increment pivot index\nif(array[i]<pivotVal){//Push two animations to swap bar heights (Use true to indicate a change)\nanimations.push([pivotIdx,array[i],true]);animations.push([i,array[pivotIdx],true]);swap(array,i,pivotIdx);pivotIdx++;}}//Once we reach the end, we highlight the pivot values determined index and the original index\n//Reset the colors and commit the swap in bar heights\nanimations.push([pivotIdx,highIndex,false]);animations.push([pivotIdx,highIndex,false]);animations.push([pivotIdx,array[highIndex],true]);animations.push([highIndex,array[pivotIdx],true]);swap(array,pivotIdx,highIndex);return pivotIdx;}export function getHeapSortAnimations(array){var animations=[];if(array.length<=1)return array;var size=array.length;doHeapSort(array,size,animations);return animations;}function doHeapSort(array,size,animations){for(var i=size/2-1;i>=0;i--){heapify(array,size,i,animations);}for(var _i=size-1;_i>=0;_i--){animations.push([_i,array[0],true]);animations.push([0,array[_i],true]);swap(array,_i,0);heapify(array,_i,0,animations);}}function heapify(array,size,i,animations){//n is the size of the heap\n//rooted at index i\nvar root=i;var left=2*i+1;var right=2*i+2;if(left<size&&array[root]<array[left]){animations.push([root,left,false]);animations.push([root,left,false]);root=left;}if(right<size&&array[root]<array[right]){animations.push([root,right,false]);animations.push([root,right,false]);root=right;}if(root!==i){animations.push([root,array[i],true]);animations.push([i,array[root],true]);//If root is not i, then swap the values, call heapify recursively\nswap(array,root,i);heapify(array,size,root,animations);}}","map":{"version":3,"sources":["/Users/kimberlyashman/Workspace/web-fun/sorting-visualizer/src/sortingAlgorithms/sortingAlgorithms.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","doMerge","k","i","j","push","swap","arr","val1","val2","temp","getBubbleSortAnimations","size","doBubbleSort","getQuickSortAnimations","doQuickSort","lowIndex","highIndex","pivot","getPivot","pivotIdx","pivotVal","getHeapSortAnimations","doHeapSort","heapify","root","left","right"],"mappings":"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","sourcesContent":["export function getMergeSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    const auxiliaryArray = array.slice();\n    mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n    return animations;\n}\n\nfunction mergeSortHelper(\n    mainArray,\n    startIdx,\n    endIdx,\n    auxiliaryArray,\n    animations,\n) {\n    if (startIdx === endIdx) return;\n    const middleIdx = Math.floor((startIdx + endIdx) / 2);\n    mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n    mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n    doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n}\n\nfunction doMerge(\n    mainArray,\n    startIdx,\n    middleIdx,\n    endIdx,\n    auxiliaryArray,\n    animations,\n) {\n    let k = startIdx;\n    let i = startIdx;\n    let j = middleIdx + 1;\n    while (i <= middleIdx && j <= endIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, j]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, j]);\n        if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n            // We overwrite the value at index k in the original array with the\n            // value at index i in the auxiliary array.\n            animations.push([k, auxiliaryArray[i]]);\n            mainArray[k++] = auxiliaryArray[i++];\n        } else {\n            // We overwrite the value at index k in the original array with the\n            // value at index j in the auxiliary array.\n            animations.push([k, auxiliaryArray[j]]);\n            mainArray[k++] = auxiliaryArray[j++];\n        }\n    }\n    while (i <= middleIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([i, i]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([i, i]);\n        // We overwrite the value at index k in the original array with the\n        // value at index i in the auxiliary array.\n        animations.push([k, auxiliaryArray[i]]);\n        mainArray[k++] = auxiliaryArray[i++];\n    }\n    while (j <= endIdx) {\n        // These are the values that we're comparing; we push them once\n        // to change their color.\n        animations.push([j, j]);\n        // These are the values that we're comparing; we push them a second\n        // time to revert their color.\n        animations.push([j, j]);\n        // We overwrite the value at index k in the original array with the\n        // value at index j in the auxiliary array.\n        animations.push([k, auxiliaryArray[j]]);\n        mainArray[k++] = auxiliaryArray[j++];\n    }\n}\n// https://github.com/Kevin6525/Sorting-Visualizer/blob/master/src/sortingAlgorithms/sortingAlgorithms.js\nfunction swap(arr, val1, val2)\n{\n    let temp = arr[val2];\n    arr[val2] = arr[val1];\n    arr[val1] = temp;\n}\n\nexport function getBubbleSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    let size = array.length;\n    doBubbleSort(array, size, animations);\n    return animations;\n}\n\nfunction doBubbleSort(mainArray, size, animations) {\n    for (let i = 0; i <size -1; i++) {\n\n        // Last i elements are already in place\n        for (let j = 0; j < (size - i - 1); j++) {\n            animations.push([i, j, false]);\n            animations.push([i, j, false]);\n            // Checking if the item at present iteration\n            // is greater than the next iteration\n            if (mainArray[j] > mainArray[j + 1]) {\n\n                // If the condition is true then swap them\n                animations.push([j,mainArray[j+1],true]);\n                animations.push([j+1,mainArray[j],true]);\n                swap(mainArray,j,j+1);\n            }\n        }\n    }\n}\n\n\nexport function getQuickSortAnimations(array) {\n    const animations = [];\n    if(array.length <= 1) return array;\n    doQuickSort(array, 0, array.length - 1, animations);\n    return animations;\n}\nfunction doQuickSort(array, lowIndex, highIndex, animations)\n{\n    if(lowIndex >= highIndex) return;\n    let pivot = getPivot(array, lowIndex, highIndex, animations);\n    doQuickSort(array, lowIndex, pivot - 1, animations);\n    doQuickSort(array, pivot + 1, highIndex, animations);\n}\n\n//This is the function to find the partition the array through pivot points\nfunction getPivot(array, lowIndex, highIndex, animations)\n{\n    // Standard quicksort, we set our last element to be our pivot value\n    // Pivot index is where the pivot value belongs in the array once sorted\n    let pivotIdx = lowIndex\n    let pivotVal = array[highIndex];\n    // Iterate through the list, note we use lowIndex as the starting index (For recursive calls)\n    for(let i = lowIndex; i < highIndex; i ++)\n    {\n        //Push the animation twice, Once to highlight it, second to reset color\n        animations.push([pivotIdx, i, false]);\n        animations.push([pivotIdx, i, false]);\n        //If the current value is less than the pivot value, than we increment pivot index\n        if(array[i] < pivotVal)\n        {\n            //Push two animations to swap bar heights (Use true to indicate a change)\n            animations.push([pivotIdx, array[i], true]);\n            animations.push([i, array[pivotIdx], true]);\n            swap(array,i,pivotIdx);\n            pivotIdx ++;\n        }\n    }\n    //Once we reach the end, we highlight the pivot values determined index and the original index\n    //Reset the colors and commit the swap in bar heights\n    animations.push([pivotIdx, highIndex, false]);\n    animations.push([pivotIdx, highIndex, false]);\n    animations.push([pivotIdx, array[highIndex], true]);\n    animations.push([highIndex, array[pivotIdx], true]);\n    swap(array, pivotIdx, highIndex);\n    return pivotIdx;\n}\n\nexport function getHeapSortAnimations(array) {\n    const animations = [];\n    if (array.length <= 1) return array;\n    let size = array.length;\n    doHeapSort(array, size, animations);\n    return animations;\n}\n\nfunction doHeapSort(array, size, animations)\n{\n    for (let i = (size/2 -1); i >= 0; i--){\n        heapify(array,size,i,animations);\n    }\n\n    for (let i = size-1; i >=0; i--){\n        animations.push([i, array[0], true]);\n        animations.push([0, array[i], true]);\n        swap(array, i, 0);\n        heapify(array, i, 0, animations);\n    }\n\n\n}\n\nfunction heapify(array, size, i, animations) {\n    //n is the size of the heap\n    //rooted at index i\n\n    let root = i;\n    let left = 2*i + 1;\n    let right = 2*i + 2;\n\n    if ((left < size) && (array[root] < array[left])){\n        animations.push([root, left, false]);\n        animations.push([root, left, false]);\n        root = left;\n    }\n\n    if ((right < size) && (array[root] < array[right])){\n        animations.push([root, right, false]);\n        animations.push([root, right, false]);\n        root = right;\n    }\n\n    if (root !== i){\n        animations.push([root, array[i], true]);\n        animations.push([i, array[root], true]);\n        //If root is not i, then swap the values, call heapify recursively\n        swap(array, root, i);\n        heapify(array, size, root, animations);\n    }\n\n}"]},"metadata":{},"sourceType":"module"}